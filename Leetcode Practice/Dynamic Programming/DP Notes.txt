Greedy Method
=============

Greedy: If input is feasible then we include input in the solution/output
//OR
Take only that solution/Input that satisfies given input constraints


Dynamic Programming Notes
=========================

It Explores all possible solutions systematically and efficiently.
It is capable of solving a wide variety of problems which has the following characteristics
	1. Overlapping Subproblems
	2. Optimal Substructure

Greedy has an Optimal Structure, but no overlapping subproblem
Divide & Conquer breaks problem into subproblems, but subproblems do not overlap

DP is a Powerful tool because it breaks a complex problem into manageable subproblem (avoid repetition sub-calculation)
DP also helps to improve TimeComplexity

2 Ways to Implement DP
	1. Tabulation: Bottom-Up Approach
	2. Memorization: Top-Down Approach

	1. Tabulation: It is implemented with iteration and starts with the Based case
	2. Memorization: It is implemented with Recursion starting from the nth case to the base case

Very IMP when 2 state changes in code
======================================
--> When you are using matrix for saving result,
In Memorization data starts filling from (0,0) index hence Memorization also called Top-Down Approach
In Tabulation, data starts filling from (size-1, size-1) hence Tabulation also called Bottom-Up Apprach


Memoizing: Store the result of subProblem(i.e. function) in Array or hashmap etc., 
re-use result again if the same subproblem occurs 

- Tabulation is faster, Memorization is slower
- Tabulation does not have headaches where Memorization has
- Memorization is easy to write, 
- Memorization does not need subproblem ordering, whereas Tabulation needs logical order
- Memorization (top-down) uses recursion, and Tabulation (bottom-up) uses iteration.

When to Use DP?

1. The first characteristic:
The problem will ask for the optimum value (maximum minimum or longest) of something, or the number of ways there are to do something.

Ex.
What is the minimum cost of doing...
What is the maximum profit from...
How many ways are there to do...
What is the longest possible...
Is it possible to reach a certain point...
//During Learning
find k nums, get min k, max k, k seq etc. (k is dynamic num to calculate)
Least No of OR Most No of something

Note: Not all DP Problems follow this format, Not all problems are solved by DP
But this format is very common in DP

2. Second characteristic: 
	Does the next problem depend on the decision of the current problem (OR)
	Future Decision depends on an earlier decision

Framework for DP Problems
=========================
- In a DP problem, a `state` is a set of variables that can sufficiently describe a scenario.
These variables are called state variables, and we only care about relevant ones.

The Framework
=============

To Solve DP Problem, we need 3 things
	1. Data structure which computes/saves/stores the result of every state (i.e. Allocate Memory for saving the result of sub-problem)
	2. Recurrence Relation to transition between states
	3. Base Case

If the problem had an added constraint such as "you are only allowed to rob up to k houses", then
k would be another necessary state variable.

Time and Space Complexity: 
-> Calculating TC and SC is not as difficult as it sounds
-> TC of DP is Directly tied to The possible states

- Make sure Akshay, When you know after getting multiple combinations and you have to find min/max/longest then it is kind of a DP problem
===============================================================

- With DP we can use logical thinking to find the answer to the original problem
- The dimension of DP is dependent on the total variable used to define each state
- Typically more dimension = more difficult (2D is Common)

1D - If the input is string or array then it needs only 1 state variable and that is 'index' (which is the default)
2D 
- If the input has string/array and also other input ex. 'k' then 'k' will be another state variable --> dp(i,k)
- If extra constrain is given in input then that constrain is another state variable (Values that describe a state in a given state)
- If any list or variable in input never get changed that list or variable has no input
Ex. in wordlist ["a"," ab", "ABC"] <-- we can use any word at n times then we cannot track word by variable 
If word change/each state needs a different word then we need to track that work, The tracking variable is another state variable for the DP

- NOTE: Check, does input is forming by output || output is forming by input

==================================================================================
In DP Problem, "doing nothing" is refer to two state variable having the same value


