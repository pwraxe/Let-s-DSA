Greedy Method
=============

Greedy: If input is feasible then we include input in the solution/output
//OR
Take only that solution/Input that satisfies given input constraints


Dynamic Programming Notes
=========================

It Explores all possible solutions systematically and efficiently.
It is capable of solving a wide variety of problems which has the following characteristics
	1. Overlapping Subproblems
	2. Optimal Substructure

Greedy has an Optimal Structure, but no overlapping subproblem
Divide & Conquer breaks problem into subproblems, but subproblems do not overlap

DP is a Powerful tool because it breaks a complex problem into manageable subproblem (avoid repetition sub-calculation)
DP also helps to improve TimeComplexity

2 Ways to Implement DP
	1. Tabulation: Bottom-Up Approach
	2. Memorization: Top-Down Approach

	1. Tabulation: It is implemented with iteration and starts with the Based case
	2. Memorization: It is implemented with Recursion starting from the nth case to the base case

Memoizing: Store the result of subProblem(i.e. function) in Array or hashmap etc., 
re-use result again if the same subproblem occurs 

- Tabulation is faster, Memorization is slower
- Tabulation does not have headaches where Memorization has
- Memorization is easy to write, 
- Memorization does not need subproblem ordering, whereas Tabulation needs logical order
- Memorization (top-down) uses recursion, and Tabulation (bottom-up) uses iteration.


When to Use DP?

1. The first characteristic:
The problem will ask for the optimum value (maximum minimum or longest) of something, or the number of ways there are to do something.

Ex.
What is the minimum cost of doing...
What is the maximum profit from...
How many ways are there to do...
What is the longest possible...
Is it possible to reach a certain point...

Note: Not all DP Problems follow this format, Not all problems are solved by DP
But this format is very common in DP

2. Second characteristic: 
	Does the next problem depend on the decision of the current problem (OR)
	Future Decision depends on an earlier decision

Framework for DP Problems
=========================
- In a DP problem, a `state` is a set of variables that can sufficiently describe a scenario.
These variables are called state variables, and we only care about relevant ones.

The Framework
=============

To Solve DP Problem, we need 3 things
	1. Data structure which compute/save/store result of every state (i.e. Allocate Memory for saving result of sub-problem)
	2. Recurrance Relation to transition between states
	3. Base Case

If the problem had an added constraint such as "you are only allowed to rob up to k houses", then
k would be another necessary state variable. 

